[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Climate Analysis with ClimRR",
    "section": "",
    "text": "Climate scenarios are the set of conditions used to represent estimates of future greenhouse gas (GHG) concentrations in the atmosphere. Climate models then evaluate how these GHG concentrations affect future (projected) climate.\nThe data in ClimRR include model results from two future climate scenarios, called Representative Concentration Pathways (RCPs):\n\nRCP4.5: in this scenario, human GHG emissions peak around 2040, then decline\nRCP8.5: in this scenario, human GHG emissions continue to rise throughout the 21-st century\n\nEach RCP is modeled over a mid-century period (2045—2054) and end-of-century-period (2081 to 2094). A historical period (1995—2004) is also modeled using GHG concentrations during this period.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport warnings\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\nimport iris\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\nwarnings.filterwarnings('ignore')\n\nfrom pathlib import Path\n\nfrom ClimRR import DATA_DIR\n\nplt.rcParams.update({\n    'axes.facecolor': 'none',\n    'figure.facecolor': 'none',\n    'savefig.facecolor': 'none',\n    'savefig.format': 'svg',\n    'axes.edgecolor': 'none',\n    'axes.grid': True,\n    'axes.labelcolor': '#666',\n    'axes.titlecolor': '#666',\n    'grid.color': '#666',\n    'text.color': '#666',\n    'grid.linestyle': '--',\n    'grid.linewidth': 0.5,\n    'grid.alpha': 0.4,\n    'xtick.color': 'none',\n    'ytick.color': 'none',\n    'xtick.labelcolor': '#666',\n    'legend.edgecolor': 'none',\n    'ytick.labelcolor': '#666',\n    'savefig.transparent': True,\n})\n\n\n\n\nCode\nshape = gpd.read_file(\n    DATA_DIR.joinpath(\"GridCellsShapefile/GridCells.shp\")\n)\nprint(f\"shape: {shape}\")\n\n\nshape:        OBJECTID Crossmodel    Shape_Leng    Shape_Area  \\\n0             1   R161C438  63614.764866  2.529273e+08   \n1             2   R125C222  61384.219597  2.355013e+08   \n2             3   R121C235  61111.892875  2.334164e+08   \n3             4   R169C431  64716.234995  2.617618e+08   \n4             5   R146C497  60142.919468  2.260731e+08   \n...         ...        ...           ...           ...   \n62829     62830   R055C359  54822.101620  1.878414e+08   \n62830     62831   R072C387  55964.448729  1.957512e+08   \n62831     62832   R085C337  57646.273207  2.076932e+08   \n62832     62833   R082C288  57528.265213  2.068438e+08   \n62833     62834   R088C416  56916.790562  2.024700e+08   \n\n                                                geometry  \n0      POLYGON ((-9530601.177 4726046.614, -9534793.8...  \n1      POLYGON ((-12959076.287 4395610.472, -12974301...  \n2      POLYGON ((-12754805.395 4355815.951, -12770000...  \n3      POLYGON ((-9605729.481 4879238.815, -9609863.1...  \n4      POLYGON ((-8733007.764 4224658.634, -8738250.3...  \n...                                                  ...  \n62829  POLYGON ((-10965528.715 3400674.224, -10966978...  \n62830  POLYGON ((-10550370.700 3584259.218, -10552496...  \n62831  POLYGON ((-11249641.912 3850046.022, -11235259...  \n62832  POLYGON ((-11942487.554 3816894.598, -11956857...  \n62833  POLYGON ((-10110300.079 3720413.967, -10124231...  \n\n[62834 rows x 5 columns]\n\n\n\n\nCode\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\nimport iris\nimport iris.analysis.cartography\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\n# Load some test data.\nfname = iris.sample_data_path(\"rotated_pole.nc\")\nair_pressure = iris.load_cube(fname)\n\n# Plot #1: Point plot showing data values & a colorbar\n# plt.figure()\nfig, ax = plt.subplots()\npoints = qplt.points(air_pressure, c=air_pressure.data)\ncb = plt.colorbar(points, orientation=\"horizontal\")\ncb.set_label(air_pressure.units)\nplt.gca().coastlines()\n\n# Plot #2: Contourf of the point based data\nplt.figure()\nqplt.contourf(air_pressure, 15)\nplt.gca().coastlines()\n# iplt.show()\n\n# Plot #3: Contourf overlaid by coloured point data\nplt.figure()\nqplt.contourf(air_pressure)\niplt.points(air_pressure, c=air_pressure.data)\nplt.gca().coastlines()\n\n# For the purposes of this example, add some bounds to the latitude\n# and longitude\nair_pressure.coord(\"grid_latitude\").guess_bounds()\nair_pressure.coord(\"grid_longitude\").guess_bounds()\n\n# Plot #4: Block plot\nplt.figure()\n# fig, ax = plt.subplots()\nplt.axes(projection=ccrs.PlateCarree())\niplt.pcolormesh(air_pressure)\nplt.gca().stock_img()\nplt.gca().coastlines()\n\n\n&lt;cartopy.mpl.feature_artist.FeatureArtist at 0x2878a82d0&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\ntemperature = iris.load_cube(fname)\n\nfig, ax = plt.subplots()\n\n# Plot #1: contourf with axes longitude from -180 to 180\n#plt.figure(figsize=(8, 5))\nplt.subplot(121)\nqplt.contourf(temperature, 15)\nfig.gca().coastlines()\n\n# Plot #2: contourf with axes longitude from 0 to 360\nproj = ccrs.PlateCarree(central_longitude=-180.0)\nplt.subplot(122, projection=proj)\nqplt.contourf(temperature, 15)\nfig.gca().coastlines()\n\n\n&lt;cartopy.mpl.feature_artist.FeatureArtist at 0x287bfef10&gt;\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\n\nfig, ax = plt.subplots()\n# Load exactly one cube from the given file.\ntemperature = iris.load_cube(fname)\n# We only want a small number of latitudes, so filter some out\n# using \"extract\".\ntemperature = temperature.extract(\n    iris.Constraint(latitude=lambda cell: 68 &lt;= cell &lt; 78)\n)\n\nfor cube in temperature.slices(\"longitude\"):\n    # Create a string label to identify this cube (i.e. latitude: value).\n    cube_label = \"latitude: %s\" % cube.coord(\"latitude\").points[0]\n\n    # Plot the cube, and associate it with a label.\n    qplt.plot(cube, label=cube_label)\n\n# Add the legend with 2 columns.\nax.legend(ncol=2)\n# Put a grid on the plot.\nax.grid(True)\n# Tell matplotlib not to extend the plot axes range to nicely\n# rounded numbers.\nplt.axis(\"tight\")\n\n\n(-17.81249542236328, 374.0624038696289, 253.4506408691406, 277.34959106445314)\n\n\n\n\n\n\n\n\nThis example demonstrates the use of a single 3D data cube with time, latitude and longitude dimensions to plot a temperature series for a single latitude coordinate, with an inset plot of the data region.\n\n\nCode\nimport numpy as np\ncube1 = iris.load_cube(iris.sample_data_path(\"ostia_monthly.nc\"))\n# Slice into cube to retrieve data for the inset map showing the\n# data region\nregion = cube1[-1, :, :]\n# Average over latitude to reduce cube to 1 dimension\nplot_line = region.collapsed(\"latitude\", iris.analysis.MEAN)\n\n# Open a window for plotting\nfig = plt.figure()\n# Add a single subplot (axes). Could also use \"ax_main = plt.subplot()\"\nax_main = fig.add_subplot(1, 1, 1)\n# Produce a quick plot of the 1D cube\nqplt.plot(plot_line)\n\n# Set x limits to match the data\nax_main.set_xlim(0, plot_line.coord(\"longitude\").points.max())\n# Adjust the y limits so that the inset map won't clash with main plot\nax_main.set_ylim(294, 310)\nax_main.set_title(\"Meridional Mean Temperature\")\n# Add grid lines\nax_main.grid()\n\n# Add a second set of axes specifying the fractional coordinates within\n# the figure with bottom left corner at x=0.55, y=0.58 with width\n# 0.3 and height 0.25.\n# Also specify the projection\nax_sub = fig.add_axes(\n  [0.55, 0.58, 0.3, 0.25],\n  projection=ccrs.Mollweide(central_longitude=180),\n)\n\n# Use iris.plot (iplt) here so colour bar properties can be specified\n# Also use a sequential colour scheme to reduce confusion for those with\n# colour-blindness\niplt.pcolormesh(region, cmap=\"Blues\")\n# Manually set the orientation and tick marks on your colour bar\nticklist = np.linspace(np.min(region.data), np.max(region.data), 4)\nplt.colorbar(orientation=\"horizontal\", ticks=ticklist)\nax_sub.set_title(\"Data Region\")\n# Add coastlines\nax_sub.coastlines()\n# request to show entire map, using the colour mesh on the data region only\nax_sub.set_global()\n\n\n\n\n\n\n\nCode\nimport iris\n\nimport numpy as np\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\nfrom iris.analysis import MEAN\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Loads air_temp.pp and \"collapses\" longitude into a single, average value.\nfname = iris.sample_data_path(\"air_temp.pp\")\ntemperature = iris.load_cube(fname)\ncollapsed_temp = temperature.collapsed(\"longitude\", MEAN)\n\n\n# Set y-axes with -90 and 90 limits and steps of 15 per tick.\nstart, stop, step = -90, 90, 15\nyticks = np.arange(start, stop + step, step)\nylim = [start, stop]\n\n# Plot \"temperature\" on a cartographic plot and set the ticks and titles\n# on the axes.\nfig = plt.figure(figsize=[12, 8])\n#fig, ax = plt.subplots()\n\nax1 = fig.add_subplot(111, projection=ccrs.PlateCarree())\nim = iplt.contourf(temperature, cmap=\"RdYlBu_r\")\nax1.coastlines()\nax1.gridlines()\nax1.set_xticks([-180, -90, 0, 90, 180])\nax1.set_yticks(yticks)\nax1.set_title(\"Air Temperature\")\nax1.set_ylabel(f\"Latitude / {temperature.coord('latitude').units}\")\nax1.set_xlabel(f\"Longitude / {temperature.coord('longitude').units}\")\nax1.set_ylim(*ylim)\n\n# Create a Matplotlib AxesDivider object to allow alignment of other\n# Axes objects.\ndivider = make_axes_locatable(ax1)\n\n# Gives the air temperature bar size, colour and a title.\nax2 = divider.new_vertical(\n    size=\"5%\", pad=0.5, axes_class=plt.Axes, pack_start=True\n)  # creates 2nd axis\nfig.add_axes(ax2)\ncbar = plt.colorbar(\n    im, cax=ax2, orientation=\"horizontal\"\n)  # puts colour bar on second axis\ncbar.ax.set_xlabel(f\"{temperature.units}\")  # labels colour bar\n\n# Plot \"collapsed_temp\" on the mean graph and set the ticks and titles\n# on the axes.\nax3 = divider.new_horizontal(\n    size=\"30%\", pad=0.4, axes_class=plt.Axes\n)  # create 3rd axis\nfig.add_axes(ax3)\nqplt.plot(\n    collapsed_temp, collapsed_temp.coord(\"latitude\")\n)  # plots temperature collapsed over longitude against latitude\nax3.axhline(0, color=\"k\", linewidth=0.5)\n\n# Creates zonal mean details\nax3.set_title(\"Zonal Mean\")\nax3.yaxis.set_label_position(\"right\")\nax3.yaxis.tick_right()\nax3.set_yticks(yticks)\nax3.grid()\n\n# Round each tick for the third ax to the nearest 20 (ready for use).\ndata_max = collapsed_temp.data.max()\nx_max = data_max - data_max % -20\ndata_min = collapsed_temp.data.min()\nx_min = data_min - data_min % 20\nax3.set_xlim(x_min, x_max)\nax3.set_ylim(*ylim)\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\n\n# Load exactly one cube from the given file.\ntemperature = iris.load_cube(fname)\n\n# We only want a small number of latitudes, so filter some out\n# using \"extract\".\ntemperature = temperature.extract(\n    iris.Constraint(latitude=lambda cell: 68 &lt;= cell &lt; 78)\n)\n\nfig, ax = plt.subplots()\n\nfor cube in temperature.slices(\"longitude\"):\n    # Create a string label to identify this cube (i.e. latitude: value).\n    cube_label = \"latitude: %s\" % cube.coord(\"latitude\").points[0]\n\n    # Plot the cube, and associate it with a label.\n    qplt.plot(cube, label=cube_label)\n\n# Add the legend with 2 columns.\nax.legend(ncol=2)\n\n# Put a grid on the plot.\nax.grid(True)\n\n# Tell matplotlib not to extend the plot axes range to nicely\n# rounded numbers.\nplt.axis(\"tight\")\n\n\n(-17.81249542236328, 374.0624038696289, 253.4506408691406, 277.34959106445314)\n\n\n\n\n\n\n\nCode\nimport iris.coord_categorisation\nimport matplotlib.colors as mcols\n\n\nfig, ax = plt.subplots()\n# Load a sample air temperatures sequence.\nfile_path = iris.sample_data_path(\"E1_north_america.nc\")\ntemperatures = iris.load_cube(file_path)\n\n# Create a year-number coordinate from the time information.\niris.coord_categorisation.add_year(temperatures, \"time\")\n\n# Create a sample anomaly field for one chosen year, by extracting that\n# year and subtracting the time mean.\nsample_year = 1982\nyear_temperature = temperatures.extract(iris.Constraint(year=sample_year))\ntime_mean = temperatures.collapsed(\"time\", iris.analysis.MEAN)\nanomaly = year_temperature - time_mean\n\n# Construct a plot title string explaining which years are involved.\nyears = temperatures.coord(\"year\").points\nplot_title = \"Temperature anomaly\"\nplot_title += \"\\n{} differences from {}-{} average.\".format(\n    sample_year, years[0], years[-1]\n)\n\n# Define scaling levels for the logarithmic colouring.\nminimum_log_level = 0.1\nmaximum_scale_level = 3.0\n\n# Use a standard colour map which varies blue-white-red.\n# For suitable options, see the 'Diverging colormaps' section in:\n# http://matplotlib.org/stable/gallery/color/colormap_reference.html\nanom_cmap = \"bwr\"\n\n# Create a 'logarithmic' data normalization.\nanom_norm = mcols.SymLogNorm(\n    linthresh=minimum_log_level,\n    linscale=0.01,\n    vmin=-maximum_scale_level,\n    vmax=maximum_scale_level,\n)\n# Setting \"linthresh=minimum_log_level\" makes its non-logarithmic\n# data range equal to our 'zero band'.\n# Setting \"linscale=0.01\" maps the whole zero band to the middle colour value\n# (i.e., 0.5), which is the neutral point of a \"diverging\" style colormap.\n\n# Create an Axes, specifying the map projection.\nplt.axes(projection=ccrs.LambertConformal())\n\n# Make a pseudocolour plot using this colour scheme.\nmesh = iplt.pcolormesh(anomaly, cmap=anom_cmap, norm=anom_norm)\n\n# Add a colourbar, with extensions to show handling of out-of-range values.\nbar = plt.colorbar(mesh, orientation=\"horizontal\", extend=\"both\")\n\n# Set some suitable fixed \"logarithmic\" colourbar tick positions.\ntick_levels = [-3, -1, -0.3, 0.0, 0.3, 1, 3]\nbar.set_ticks(tick_levels)\n\n# Modify the tick labels so that the centre one shows \"+/-&lt;minumum-level&gt;\".\ntick_levels[3] = r\"$\\pm${:g}\".format(minimum_log_level)\nbar.set_ticklabels(tick_levels)\n\n# Label the colourbar to show the units.\nbar.set_label(\"[{}, log scale]\".format(anomaly.units))\n\n# Add coastlines and a title.\nplt.gca().coastlines()\nplt.title(plot_title)\n\n\nText(0.5, 1.0, 'Temperature anomaly\\n1982 differences from 1860-2099 average.')"
  },
  {
    "objectID": "index.html#climate-scenarios",
    "href": "index.html#climate-scenarios",
    "title": "Climate Analysis with ClimRR",
    "section": "",
    "text": "Climate scenarios are the set of conditions used to represent estimates of future greenhouse gas (GHG) concentrations in the atmosphere. Climate models then evaluate how these GHG concentrations affect future (projected) climate.\nThe data in ClimRR include model results from two future climate scenarios, called Representative Concentration Pathways (RCPs):\n\nRCP4.5: in this scenario, human GHG emissions peak around 2040, then decline\nRCP8.5: in this scenario, human GHG emissions continue to rise throughout the 21-st century\n\nEach RCP is modeled over a mid-century period (2045—2054) and end-of-century-period (2081 to 2094). A historical period (1995—2004) is also modeled using GHG concentrations during this period.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport warnings\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\nimport iris\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\nwarnings.filterwarnings('ignore')\n\nfrom pathlib import Path\n\nfrom ClimRR import DATA_DIR\n\nplt.rcParams.update({\n    'axes.facecolor': 'none',\n    'figure.facecolor': 'none',\n    'savefig.facecolor': 'none',\n    'savefig.format': 'svg',\n    'axes.edgecolor': 'none',\n    'axes.grid': True,\n    'axes.labelcolor': '#666',\n    'axes.titlecolor': '#666',\n    'grid.color': '#666',\n    'text.color': '#666',\n    'grid.linestyle': '--',\n    'grid.linewidth': 0.5,\n    'grid.alpha': 0.4,\n    'xtick.color': 'none',\n    'ytick.color': 'none',\n    'xtick.labelcolor': '#666',\n    'legend.edgecolor': 'none',\n    'ytick.labelcolor': '#666',\n    'savefig.transparent': True,\n})\n\n\n\n\nCode\nshape = gpd.read_file(\n    DATA_DIR.joinpath(\"GridCellsShapefile/GridCells.shp\")\n)\nprint(f\"shape: {shape}\")\n\n\nshape:        OBJECTID Crossmodel    Shape_Leng    Shape_Area  \\\n0             1   R161C438  63614.764866  2.529273e+08   \n1             2   R125C222  61384.219597  2.355013e+08   \n2             3   R121C235  61111.892875  2.334164e+08   \n3             4   R169C431  64716.234995  2.617618e+08   \n4             5   R146C497  60142.919468  2.260731e+08   \n...         ...        ...           ...           ...   \n62829     62830   R055C359  54822.101620  1.878414e+08   \n62830     62831   R072C387  55964.448729  1.957512e+08   \n62831     62832   R085C337  57646.273207  2.076932e+08   \n62832     62833   R082C288  57528.265213  2.068438e+08   \n62833     62834   R088C416  56916.790562  2.024700e+08   \n\n                                                geometry  \n0      POLYGON ((-9530601.177 4726046.614, -9534793.8...  \n1      POLYGON ((-12959076.287 4395610.472, -12974301...  \n2      POLYGON ((-12754805.395 4355815.951, -12770000...  \n3      POLYGON ((-9605729.481 4879238.815, -9609863.1...  \n4      POLYGON ((-8733007.764 4224658.634, -8738250.3...  \n...                                                  ...  \n62829  POLYGON ((-10965528.715 3400674.224, -10966978...  \n62830  POLYGON ((-10550370.700 3584259.218, -10552496...  \n62831  POLYGON ((-11249641.912 3850046.022, -11235259...  \n62832  POLYGON ((-11942487.554 3816894.598, -11956857...  \n62833  POLYGON ((-10110300.079 3720413.967, -10124231...  \n\n[62834 rows x 5 columns]\n\n\n\n\nCode\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\n\nimport iris\nimport iris.analysis.cartography\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\n# Load some test data.\nfname = iris.sample_data_path(\"rotated_pole.nc\")\nair_pressure = iris.load_cube(fname)\n\n# Plot #1: Point plot showing data values & a colorbar\n# plt.figure()\nfig, ax = plt.subplots()\npoints = qplt.points(air_pressure, c=air_pressure.data)\ncb = plt.colorbar(points, orientation=\"horizontal\")\ncb.set_label(air_pressure.units)\nplt.gca().coastlines()\n\n# Plot #2: Contourf of the point based data\nplt.figure()\nqplt.contourf(air_pressure, 15)\nplt.gca().coastlines()\n# iplt.show()\n\n# Plot #3: Contourf overlaid by coloured point data\nplt.figure()\nqplt.contourf(air_pressure)\niplt.points(air_pressure, c=air_pressure.data)\nplt.gca().coastlines()\n\n# For the purposes of this example, add some bounds to the latitude\n# and longitude\nair_pressure.coord(\"grid_latitude\").guess_bounds()\nair_pressure.coord(\"grid_longitude\").guess_bounds()\n\n# Plot #4: Block plot\nplt.figure()\n# fig, ax = plt.subplots()\nplt.axes(projection=ccrs.PlateCarree())\niplt.pcolormesh(air_pressure)\nplt.gca().stock_img()\nplt.gca().coastlines()\n\n\n&lt;cartopy.mpl.feature_artist.FeatureArtist at 0x2878a82d0&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\ntemperature = iris.load_cube(fname)\n\nfig, ax = plt.subplots()\n\n# Plot #1: contourf with axes longitude from -180 to 180\n#plt.figure(figsize=(8, 5))\nplt.subplot(121)\nqplt.contourf(temperature, 15)\nfig.gca().coastlines()\n\n# Plot #2: contourf with axes longitude from 0 to 360\nproj = ccrs.PlateCarree(central_longitude=-180.0)\nplt.subplot(122, projection=proj)\nqplt.contourf(temperature, 15)\nfig.gca().coastlines()\n\n\n&lt;cartopy.mpl.feature_artist.FeatureArtist at 0x287bfef10&gt;\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\n\nfig, ax = plt.subplots()\n# Load exactly one cube from the given file.\ntemperature = iris.load_cube(fname)\n# We only want a small number of latitudes, so filter some out\n# using \"extract\".\ntemperature = temperature.extract(\n    iris.Constraint(latitude=lambda cell: 68 &lt;= cell &lt; 78)\n)\n\nfor cube in temperature.slices(\"longitude\"):\n    # Create a string label to identify this cube (i.e. latitude: value).\n    cube_label = \"latitude: %s\" % cube.coord(\"latitude\").points[0]\n\n    # Plot the cube, and associate it with a label.\n    qplt.plot(cube, label=cube_label)\n\n# Add the legend with 2 columns.\nax.legend(ncol=2)\n# Put a grid on the plot.\nax.grid(True)\n# Tell matplotlib not to extend the plot axes range to nicely\n# rounded numbers.\nplt.axis(\"tight\")\n\n\n(-17.81249542236328, 374.0624038696289, 253.4506408691406, 277.34959106445314)"
  },
  {
    "objectID": "index.html#test-data-showing-inset-plots",
    "href": "index.html#test-data-showing-inset-plots",
    "title": "Climate Analysis with ClimRR",
    "section": "",
    "text": "This example demonstrates the use of a single 3D data cube with time, latitude and longitude dimensions to plot a temperature series for a single latitude coordinate, with an inset plot of the data region.\n\n\nCode\nimport numpy as np\ncube1 = iris.load_cube(iris.sample_data_path(\"ostia_monthly.nc\"))\n# Slice into cube to retrieve data for the inset map showing the\n# data region\nregion = cube1[-1, :, :]\n# Average over latitude to reduce cube to 1 dimension\nplot_line = region.collapsed(\"latitude\", iris.analysis.MEAN)\n\n# Open a window for plotting\nfig = plt.figure()\n# Add a single subplot (axes). Could also use \"ax_main = plt.subplot()\"\nax_main = fig.add_subplot(1, 1, 1)\n# Produce a quick plot of the 1D cube\nqplt.plot(plot_line)\n\n# Set x limits to match the data\nax_main.set_xlim(0, plot_line.coord(\"longitude\").points.max())\n# Adjust the y limits so that the inset map won't clash with main plot\nax_main.set_ylim(294, 310)\nax_main.set_title(\"Meridional Mean Temperature\")\n# Add grid lines\nax_main.grid()\n\n# Add a second set of axes specifying the fractional coordinates within\n# the figure with bottom left corner at x=0.55, y=0.58 with width\n# 0.3 and height 0.25.\n# Also specify the projection\nax_sub = fig.add_axes(\n  [0.55, 0.58, 0.3, 0.25],\n  projection=ccrs.Mollweide(central_longitude=180),\n)\n\n# Use iris.plot (iplt) here so colour bar properties can be specified\n# Also use a sequential colour scheme to reduce confusion for those with\n# colour-blindness\niplt.pcolormesh(region, cmap=\"Blues\")\n# Manually set the orientation and tick marks on your colour bar\nticklist = np.linspace(np.min(region.data), np.max(region.data), 4)\nplt.colorbar(orientation=\"horizontal\", ticks=ticklist)\nax_sub.set_title(\"Data Region\")\n# Add coastlines\nax_sub.coastlines()\n# request to show entire map, using the colour mesh on the data region only\nax_sub.set_global()\n\n\n\n\n\n\n\nCode\nimport iris\n\nimport numpy as np\nimport iris.plot as iplt\nimport iris.quickplot as qplt\n\nfrom iris.analysis import MEAN\n\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n# Loads air_temp.pp and \"collapses\" longitude into a single, average value.\nfname = iris.sample_data_path(\"air_temp.pp\")\ntemperature = iris.load_cube(fname)\ncollapsed_temp = temperature.collapsed(\"longitude\", MEAN)\n\n\n# Set y-axes with -90 and 90 limits and steps of 15 per tick.\nstart, stop, step = -90, 90, 15\nyticks = np.arange(start, stop + step, step)\nylim = [start, stop]\n\n# Plot \"temperature\" on a cartographic plot and set the ticks and titles\n# on the axes.\nfig = plt.figure(figsize=[12, 8])\n#fig, ax = plt.subplots()\n\nax1 = fig.add_subplot(111, projection=ccrs.PlateCarree())\nim = iplt.contourf(temperature, cmap=\"RdYlBu_r\")\nax1.coastlines()\nax1.gridlines()\nax1.set_xticks([-180, -90, 0, 90, 180])\nax1.set_yticks(yticks)\nax1.set_title(\"Air Temperature\")\nax1.set_ylabel(f\"Latitude / {temperature.coord('latitude').units}\")\nax1.set_xlabel(f\"Longitude / {temperature.coord('longitude').units}\")\nax1.set_ylim(*ylim)\n\n# Create a Matplotlib AxesDivider object to allow alignment of other\n# Axes objects.\ndivider = make_axes_locatable(ax1)\n\n# Gives the air temperature bar size, colour and a title.\nax2 = divider.new_vertical(\n    size=\"5%\", pad=0.5, axes_class=plt.Axes, pack_start=True\n)  # creates 2nd axis\nfig.add_axes(ax2)\ncbar = plt.colorbar(\n    im, cax=ax2, orientation=\"horizontal\"\n)  # puts colour bar on second axis\ncbar.ax.set_xlabel(f\"{temperature.units}\")  # labels colour bar\n\n# Plot \"collapsed_temp\" on the mean graph and set the ticks and titles\n# on the axes.\nax3 = divider.new_horizontal(\n    size=\"30%\", pad=0.4, axes_class=plt.Axes\n)  # create 3rd axis\nfig.add_axes(ax3)\nqplt.plot(\n    collapsed_temp, collapsed_temp.coord(\"latitude\")\n)  # plots temperature collapsed over longitude against latitude\nax3.axhline(0, color=\"k\", linewidth=0.5)\n\n# Creates zonal mean details\nax3.set_title(\"Zonal Mean\")\nax3.yaxis.set_label_position(\"right\")\nax3.yaxis.tick_right()\nax3.set_yticks(yticks)\nax3.grid()\n\n# Round each tick for the third ax to the nearest 20 (ready for use).\ndata_max = collapsed_temp.data.max()\nx_max = data_max - data_max % -20\ndata_min = collapsed_temp.data.min()\nx_min = data_min - data_min % 20\nax3.set_xlim(x_min, x_max)\nax3.set_ylim(*ylim)\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nfname = iris.sample_data_path(\"air_temp.pp\")\n\n# Load exactly one cube from the given file.\ntemperature = iris.load_cube(fname)\n\n# We only want a small number of latitudes, so filter some out\n# using \"extract\".\ntemperature = temperature.extract(\n    iris.Constraint(latitude=lambda cell: 68 &lt;= cell &lt; 78)\n)\n\nfig, ax = plt.subplots()\n\nfor cube in temperature.slices(\"longitude\"):\n    # Create a string label to identify this cube (i.e. latitude: value).\n    cube_label = \"latitude: %s\" % cube.coord(\"latitude\").points[0]\n\n    # Plot the cube, and associate it with a label.\n    qplt.plot(cube, label=cube_label)\n\n# Add the legend with 2 columns.\nax.legend(ncol=2)\n\n# Put a grid on the plot.\nax.grid(True)\n\n# Tell matplotlib not to extend the plot axes range to nicely\n# rounded numbers.\nplt.axis(\"tight\")\n\n\n(-17.81249542236328, 374.0624038696289, 253.4506408691406, 277.34959106445314)\n\n\n\n\n\n\n\nCode\nimport iris.coord_categorisation\nimport matplotlib.colors as mcols\n\n\nfig, ax = plt.subplots()\n# Load a sample air temperatures sequence.\nfile_path = iris.sample_data_path(\"E1_north_america.nc\")\ntemperatures = iris.load_cube(file_path)\n\n# Create a year-number coordinate from the time information.\niris.coord_categorisation.add_year(temperatures, \"time\")\n\n# Create a sample anomaly field for one chosen year, by extracting that\n# year and subtracting the time mean.\nsample_year = 1982\nyear_temperature = temperatures.extract(iris.Constraint(year=sample_year))\ntime_mean = temperatures.collapsed(\"time\", iris.analysis.MEAN)\nanomaly = year_temperature - time_mean\n\n# Construct a plot title string explaining which years are involved.\nyears = temperatures.coord(\"year\").points\nplot_title = \"Temperature anomaly\"\nplot_title += \"\\n{} differences from {}-{} average.\".format(\n    sample_year, years[0], years[-1]\n)\n\n# Define scaling levels for the logarithmic colouring.\nminimum_log_level = 0.1\nmaximum_scale_level = 3.0\n\n# Use a standard colour map which varies blue-white-red.\n# For suitable options, see the 'Diverging colormaps' section in:\n# http://matplotlib.org/stable/gallery/color/colormap_reference.html\nanom_cmap = \"bwr\"\n\n# Create a 'logarithmic' data normalization.\nanom_norm = mcols.SymLogNorm(\n    linthresh=minimum_log_level,\n    linscale=0.01,\n    vmin=-maximum_scale_level,\n    vmax=maximum_scale_level,\n)\n# Setting \"linthresh=minimum_log_level\" makes its non-logarithmic\n# data range equal to our 'zero band'.\n# Setting \"linscale=0.01\" maps the whole zero band to the middle colour value\n# (i.e., 0.5), which is the neutral point of a \"diverging\" style colormap.\n\n# Create an Axes, specifying the map projection.\nplt.axes(projection=ccrs.LambertConformal())\n\n# Make a pseudocolour plot using this colour scheme.\nmesh = iplt.pcolormesh(anomaly, cmap=anom_cmap, norm=anom_norm)\n\n# Add a colourbar, with extensions to show handling of out-of-range values.\nbar = plt.colorbar(mesh, orientation=\"horizontal\", extend=\"both\")\n\n# Set some suitable fixed \"logarithmic\" colourbar tick positions.\ntick_levels = [-3, -1, -0.3, 0.0, 0.3, 1, 3]\nbar.set_ticks(tick_levels)\n\n# Modify the tick labels so that the centre one shows \"+/-&lt;minumum-level&gt;\".\ntick_levels[3] = r\"$\\pm${:g}\".format(minimum_log_level)\nbar.set_ticklabels(tick_levels)\n\n# Label the colourbar to show the units.\nbar.set_label(\"[{}, log scale]\".format(anomaly.units))\n\n# Add coastlines and a title.\nplt.gca().coastlines()\nplt.title(plot_title)\n\n\nText(0.5, 1.0, 'Temperature anomaly\\n1982 differences from 1860-2099 average.')"
  }
]